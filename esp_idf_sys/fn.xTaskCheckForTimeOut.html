<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="@cond !DOC_EXCLUDE_HEADER_SECTION task.h @code BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ); @endcode @endcond"><meta name="keywords" content="rust, rustlang, rust-lang, xTaskCheckForTimeOut"><title>xTaskCheckForTimeOut in esp_idf_sys - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../esp_idf_sys/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../esp_idf_sys/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><div class="sidebar-elems"><h2 class="location"><a href="index.html">In esp_idf_sys</a></h2></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../esp_idf_sys/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn"><span class="in-band">Function <a href="index.html">esp_idf_sys</a>::<wbr><a class="fn" href="#">xTaskCheckForTimeOut</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/esp_idf_sys/home/runner/work/esp-idf-svc/esp-idf-svc/target/riscv32imc-esp-espidf/debug/build/esp-idf-sys-16680997ab9ad3a2/out/bindings.rs.html#19540-19543">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust fn"><code>pub unsafe extern &quot;C&quot; fn xTaskCheckForTimeOut(<br>&nbsp;&nbsp;&nbsp;&nbsp;pxTimeOut: *mut <a class="type" href="type.TimeOut_t.html" title="type esp_idf_sys::TimeOut_t">TimeOut_t</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;pxTicksToWait: *mut <a class="type" href="type.TickType_t.html" title="type esp_idf_sys::TickType_t">TickType_t</a><br>) -&gt; <a class="type" href="type.BaseType_t.html" title="type esp_idf_sys::BaseType_t">BaseType_t</a></code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>@cond !DOC_EXCLUDE_HEADER_SECTION
task.h
@code
BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait );
@endcode
@endcond</p>
<p>Determines if pxTicksToWait ticks has passed since a time was captured
using a call to vTaskSetTimeOutState().  The captured time includes the tick
count and the number of times the tick count has overflowed.</p>
<p>@param pxTimeOut The time status as captured previously using
vTaskSetTimeOutState. If the timeout has not yet occurred, it is updated
to reflect the current time status.
@param pxTicksToWait The number of ticks to check for timeout i.e. if
pxTicksToWait ticks have passed since pxTimeOut was last updated (either by
vTaskSetTimeOutState() or xTaskCheckForTimeOut()), the timeout has occurred.
If the timeout has not occurred, pxTicksToWait is updated to reflect the
number of remaining ticks.</p>
<p>@return If timeout has occurred, pdTRUE is returned. Otherwise pdFALSE is
returned and pxTicksToWait is updated to reflect the number of remaining
ticks.</p>
<p>@see https://www.FreeRTOS.org/xTaskCheckForTimeOut.html</p>
<p>Example Usage:
@code
// Driver library function used to receive uxWantedBytes from an Rx buffer
// that is filled by a UART interrupt. If there are not enough bytes in the
// Rx buffer then the task enters the Blocked state until it is notified that
// more data has been placed into the buffer. If there is still not enough
// data then the task re-enters the Blocked state, and xTaskCheckForTimeOut()
// is used to re-calculate the Block time to ensure the total amount of time
// spent in the Blocked state does not exceed MAX_TIME_TO_WAIT. This
// continues until either the buffer contains at least uxWantedBytes bytes,
// or the total amount of time spent in the Blocked state reaches
// MAX_TIME_TO_WAIT – at which point the task reads however many bytes are
// available up to a maximum of uxWantedBytes.</p>
<p>size_t xUART_Receive( uint8_t *pucBuffer, size_t uxWantedBytes )
{
size_t uxReceived = 0;
TickType_t xTicksToWait = MAX_TIME_TO_WAIT;
TimeOut_t xTimeOut;</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="comment">// Initialize xTimeOut.  This records the time at which this function</span>
 <span class="comment">// was entered.</span>
 <span class="ident">vTaskSetTimeOutState</span>( <span class="kw-2">&amp;</span><span class="ident">xTimeOut</span> );

 <span class="comment">// Loop until the buffer contains the wanted number of bytes, or a</span>
 <span class="comment">// timeout occurs.</span>
 <span class="kw">while</span>( <span class="ident">UART_bytes_in_rx_buffer</span>( <span class="ident">pxUARTInstance</span> ) <span class="op">&lt;</span> <span class="ident">uxWantedBytes</span> )
 {
     <span class="comment">// The buffer didn&#39;t contain enough data so this task is going to</span>
     <span class="comment">// enter the Blocked state. Adjusting xTicksToWait to account for</span>
     <span class="comment">// any time that has been spent in the Blocked state within this</span>
     <span class="comment">// function so far to ensure the total amount of time spent in the</span>
     <span class="comment">// Blocked state does not exceed MAX_TIME_TO_WAIT.</span>
     <span class="kw">if</span>( <span class="ident">xTaskCheckForTimeOut</span>( <span class="kw-2">&amp;</span><span class="ident">xTimeOut</span>, <span class="kw-2">&amp;</span><span class="ident">xTicksToWait</span> ) <span class="op">!</span><span class="op">=</span> <span class="ident">pdFALSE</span> )
     {
         <span class="comment">//Timed out before the wanted number of bytes were available,</span>
         <span class="comment">// exit the loop.</span>
         <span class="kw">break</span>;
     }

     <span class="comment">// Wait for a maximum of xTicksToWait ticks to be notified that the</span>
     <span class="comment">// receive interrupt has placed more data into the buffer.</span>
     <span class="ident">ulTaskNotifyTake</span>( <span class="ident">pdTRUE</span>, <span class="ident">xTicksToWait</span> );
 }

 <span class="comment">// Attempt to read uxWantedBytes from the receive buffer into pucBuffer.</span>
 <span class="comment">// The actual number of bytes read (which might be less than</span>
 <span class="comment">// uxWantedBytes) is returned.</span>
 <span class="ident">uxReceived</span> <span class="op">=</span> <span class="ident">UART_read_from_receive_buffer</span>( <span class="ident">pxUARTInstance</span>,
                                             <span class="ident">pucBuffer</span>,
                                             <span class="ident">uxWantedBytes</span> );

 <span class="kw">return</span> <span class="ident">uxReceived</span>;</code></pre></div>
<p>}
@endcode
@cond !DOC_SINGLE_GROUP
\defgroup xTaskCheckForTimeOut xTaskCheckForTimeOut
@endcond
\ingroup TaskCtrl</p>
</div></details></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="esp_idf_sys" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0-nightly (d394408fb 2022-08-07)" ></div></body></html>